#+title: SIMPSIM

* Get Started

** Dependencies

Simpsim is written in Guile Scheme, so it is recommended the user install the
latest stable version. For information, visit https://www.gnu.org/software/guile/.

Simpsim produces shell scripts. These should run in any POSIX-compliant shell,
but most testing has used Bash.

As Simpsim is extensible, it is possible that produced scripts use commands
which are not on the host system.
Standard scripts however only use standard tools such as =grep= and =sed=,
which the user is very likely to have if they are using any GNU/Linux disro.

** System Setup

In order to use Simpsim, we need two things:

1. For Guile to recognise the Simpsim modules
2. For Simpsim scripts to be callable


*** Guile Modules

The simplest way to make Guile recognise Simpsim, is to add the repo root
to your =GUILE_LOAD_PATH=,

#+begin_src bash
  export GUILE_LOAD_PATH="/path/to/simpsim:$GUILE_LOAD_PATH"
#+end_src

To check that this has worked, start a =guile= REPL and run,

#+begin_src scheme
  (use-modules (simpsim)
			   (simpsim formats)
			   (simpsim edits)
			   (simpsim metas))
#+end_src

It should execute without issue.

*** Shell Scripts

Add the Simpsim root to your =PATH=,

#+begin_src bash
  export PATH="/path/to/simpsim:$PATH"
#+end_src

* Tutorial

** Exporting

Exporting can be used in many contexts e.g.

- exporting a build of a project
- exporting a set up scripts which make up a workflow
- exporting a significant run
  
Many exports are similar in the sense that they belong to the same project
and contain similar files with small changes. 
The problem of managing these becomes worse when we consider differences
in compiled binaries. 

Thus, when exporting, it is useful to have metadata. 
For example, the date of export, or the Git branch we happen
to have checked out. 
It is convenient to have these computed automatically on export. 

The `simpsim` Guile module provides the function `make-export`, 
which takes as input a data structure representing the exported bundle. 
The function returns a Bash script in string form. 

Here is an example of a simple export script. 

#+begin_src scheme
  (use-modules (simpsim)
  			 (simpsim metas))

  (define my-export
    `("project"
  	(files . "exe/compiled-code")
  	(dirs  . "par")
  	(meta (branch . ,(meta-git-current-branch))
  		  (commit . ,(meta-git-head-commit))
  		  (date   . "$(date)")
  		  (seconds . "$(date +%s)"))))

  (display (make-export "$HOME/simpsim-data" my-export))
#+end_src

The final line constructs the script which exports the desired data and metadata,
then prints it to standard output.

Observer that the script does not execute the commands in the script.
Simpsim itself does not interact with the file system.
Rather, it produces scripts which do, and the user should pipe this script
into a shell (upon reviewing of course).

#+begin_example
$ guile -s export.scm | sh
#+end_example

A subdirectory of =$HOME/simpsim-data= called =project-<uuid>= is created and the given files
and directories are copied to it.
The =<uuid>= guarantee no name clashes in the root. 
There is then a =meta= subdirectory which contains information distinguishing
exports under the same project name.

** Importing

A list of exports under the name =project= are listed by running:

#+begin_example
$ getsim project
#+end_example

All listed directories will be subdirectories of the directory specified in
environment variable =SIMPSIM_ROOT=. In general, we expect many subdirectories
to be listed. The can be filtered according to the value of their metadata.
For example, if we want a version of our code which was built on the
experimental branch we might run:

#+begin_example
$ getsim project | simmeta branch experimental
#+end_example

Furthermore, if there are still multiple exports, we can select the one
which was built most recently with:

#+begin_example
$ getsim project | simmeta branch experimental | simrecent
#+end_example

When we have a single directory, we can then copy that directory to our working directory.

#+begin_example
$ getsim project | simmeta branch experimental | simrecent | (tee && echo data) | xargs cp -r
#+end_example


** Instancing

There are many scenarios in which we want to set up many runs from
identical or similar data.
Identical data might be in the form of compiled binaries or data tables.
Similar data could be for example parameter files which we would like
to modify slightly for each run.

Instancing comprises three steps:
- define a basic template
- define a set of modifications to the template
- define an instance

Here is a simple template:

#+begin_src scheme
	(use-modules (simpsim edits)
				 (simpsim formats))
			   
	(define (less-than a)
	  (lambda (x) (< x a))))

	(define template
	  `((data-dir . "data")
		(carbons "compiled-code")
		(editables (parfile (src . "par/basic.par")
							(dst . "input.par")
							(edits (grid-spacing . ,(c-double-format (c-style-param "dx")))
								   (time-step    . ,(c-double-format (c-style-param "dt")))
								   (cfl . ,((edit-compose c-style-param
														  (remove-when (less-than 0)))
											"cfl")))))))
#+end_src

Templates consist of two parts: carbons and editables.
The =carbons= are /carbon copies/ of files in the data directory.
The =editables= are files which are modified in some way for our instance.
The =edits= are handles to functions which, given some value, return a script
for making the necessary edit to the file.

The =c-double-format= is a format wratter for the standard edit =c-style-param=,
which ensures that a Scheme double will be formatted correctly as a string,
which is then passed to =c-style-param=.

The =edit-compose= allows us to make sequential edits corresponding to the same variable.
The =c-style-param= and =(remove-when (less-than 0))= are both acceptable edits on their own.
But together, they allow an instance to set a value of some parameter and for the
parameter to be conditionally deleted from the file.

Once a template is defined, we define modifications e.g.

#+begin_src scheme
  (define (calculate-dt dx cfl dt0)
	(if (< (/ dt0 dx) cfl) dt0
		(calculate-dt dx cfl (/ dt0 2))))
  
  (define setup-grid (dx cfl dt0)
	`((editable . parfile)
	  (vars (grid-spacting . ,dx)
			(time-step     . ,(calculate-dt dx cfl dt0)))))

  (define setup-output (dx cfl t-plt t-chk)
	(let (dt (calculate-dt dx cfl t-chk))
	  `((editable . parfile)
		(vars (checkpoint-steps . ,(/ t-chk dt))
			  (plot-steps       . ,(/ t-plt dt))))))
#+end_src

Then the instance, which typically defines a single run of our simulation,

#+begin_src scheme
  (define (sim-run dx cfl t-plt t-chk)
	`((run-dir . (format #f "run-dr=~,4f" dr))
	  (template . ,template)
	  (ammendments ,(setup-grid dx cfl t-chk)
				   ,(setup-output dx cfl t-plt t-chk))))
#+end_src

With all this, we can obtain the Bash script generating a desired run with e.g.

#+begin_src scheme
  (use-modules (simpsim))
  
  (display (make-script (sim-run 0.001 0.4 0.1 5.0)))
#+end_src

** Creating Many (related) Runs

For single runs, using a tool like Simpsim is likely unnecessary.
However, if we wish to created many related runs, Simpsim helps us
to systematically generate the correct parameters in a way which
evades human error.

The example which was the inspiration for Simpsim is creating a set of runs
for a convergence test. With the framework above,

#+begin_src scheme
  (use-modules (simpsim))
  
  (define (res-pair dx)
	(list dx (/ dx 3.0)))

  (display (string-concatenate (map make-script
									(map (lambda (dx) (sim-run dx 0.4 0.1 5.0))
										 (delete-duplicates
										  (apply append
												 (map res-pair
													  '(0.3 0.27 0.24 0.21 0.18
															0.15 0.12 0.09 0.06
															0.03 0.027 0.024 0.021 0.018
															0.015 0.012 0.009 0.006
															0.003))))))))
#+end_src

The produced script creates many runs over a range of spatial resolutions.
The time steps are selected automatically such that:

- They satisfy the CFL condition
- They evenly divide (to double precision) the checkpoint time =T\=5.0=


The data produced by these simulations is then ideal for studying the convergence
of a numerical scheme impelemented by the simulation.
